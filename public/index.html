<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PRISMA — See what happens before it happens.</title>
  <meta name="description" content="Upload your spreadsheet. Test every decision before you commit. See what happens before it happens.">

  <!-- Preload pixel font -->
  <link rel="preload" href="/fonts/GeistPixel-Triangle.woff2" as="font" type="font/woff2" crossorigin>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&display=swap" rel="stylesheet">

  <style>
    /* ====== FONT ====== */
    @font-face {
      font-family: 'Geist Pixel Triangle';
      src: url('/fonts/GeistPixel-Triangle.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    /* ====== VARIABLES ====== */
    :root {
      --bg: #F5F0F0;
      --text: #14141C;
      --text2: #43394c;
      --text3: #786065;
      --accent: #2563eb;
      --accent-dark: #1d4ed8;
      --rose: #E3B2B3;
      --font-pixel: 'Geist Pixel Triangle', monospace;
      --font-sans: 'Geist', system-ui, -apple-system, sans-serif;
      --font-mono: 'Geist Mono', 'SF Mono', monospace;
      --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
    }

    /* ====== RESET ====== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html { height: 100%; scroll-behavior: smooth; }
    body { min-height: 100%; }

    body {
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      position: relative;
    }

    /* ====== INTERACTIVE DOT GRID (canvas, replaces body::before) ====== */
    #dot-grid-canvas {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }

    /* ====== GLOW BEHIND HERO ====== */
    .glow {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }
    .glow::before {
      content: '';
      position: absolute;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      width: 600px;
      height: 500px;
      background:
        radial-gradient(ellipse at center, rgba(37, 99, 235, 0.06) 0%, transparent 70%),
        radial-gradient(ellipse at 60% 40%, rgba(16, 185, 129, 0.04) 0%, transparent 60%);
      filter: blur(40px);
    }

    /* ====== TOP BAR ====== */
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      text-align: center;
      padding: 12px 24px;
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text3);
      letter-spacing: 0.02em;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0s forwards;
    }
    .top-bar .highlight {
      color: var(--accent);
      font-weight: 600;
    }

    /* ====== HERO SECTION ====== */
    .hero-section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 1;
    }

    .hero {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 0;
      max-width: 640px;
      padding: 0 24px;
    }

    /* ====== PRISM ICON ====== */
    .prism-icon {
      margin-bottom: 24px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.15s forwards;
    }
    .prism-icon svg {
      filter: drop-shadow(0 0 12px rgba(37, 99, 235, 0.15));
      animation: prismPulse 4s ease-in-out infinite;
    }
    @keyframes prismPulse {
      0%, 100% { filter: drop-shadow(0 0 12px rgba(37, 99, 235, 0.15)); }
      50%      { filter: drop-shadow(0 0 24px rgba(37, 99, 235, 0.25)); }
    }

    /* ====== BRAND NAME ====== */
    .brand {
      font-family: var(--font-pixel);
      font-size: clamp(4rem, 8vw, 7rem);
      font-weight: 400;
      letter-spacing: 0.06em;
      color: var(--text);
      line-height: 1;
      margin-bottom: 12px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.30s forwards;
    }

    /* ====== TAGLINE ====== */
    .tagline {
      font-family: var(--font-sans);
      font-size: 20px;
      font-weight: 600;
      color: var(--text2);
      margin-bottom: 12px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.50s forwards;
    }

    /* ====== SUBTITLE ====== */
    .subtitle {
      font-family: var(--font-sans);
      font-size: 15px;
      font-weight: 400;
      color: var(--text3);
      line-height: 1.6;
      margin-bottom: 32px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.60s forwards;
    }

    /* ====== CTA BUTTON (dark, with canvas particles) ====== */
    .cta {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 18px 40px;
      background: #1A1520;
      color: #F5F0F0;
      border: 1px solid rgba(245, 192, 192, 0.18);
      border-radius: 6px;
      font-family: var(--font-sans);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.3s ease, border-color 0.3s ease;
      text-decoration: none;
      margin-bottom: 40px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.75s forwards;
      overflow: hidden;
    }
    .cta:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(26, 21, 32, 0.15);
      border-color: rgba(245, 240, 240, 0.35);
    }
    .cta:active { transform: translateY(0); }
    .cta:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 4px;
    }

    .cta-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .cta-content {
      position: relative;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .cta-arrow {
      transition: transform 0.3s ease;
      opacity: 0.85;
    }
    .cta:hover .cta-arrow {
      transform: translateX(4px);
      opacity: 1;
    }

    /* Static CTA (no hero animation, used in scroll sections) */
    .cta-static {
      opacity: 1;
      animation: none;
      margin-bottom: 0;
      padding: 22px 52px;
      font-size: 18px;
    }

    /* ====== TRUST LINE ====== */
    .trust-line {
      font-family: var(--font-mono);
      font-size: 0.8rem;
      color: rgba(60,40,40,0.45);
      letter-spacing: 0.02em;
      margin-top: -28px;
      margin-bottom: 32px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.85s forwards;
    }

    /* ====== ACCENT LINE ====== */
    .accent-line {
      width: 200px;
      height: 1px;
      margin-bottom: 36px;
      opacity: 0;
      animation: fadeUp 0.5s var(--ease-out) 0.90s forwards;
      position: relative;
    }
    .accent-line::after {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      height: 1px;
      background: linear-gradient(90deg, var(--accent), var(--rose), #10B981);
      animation: lineGrow 0.8s var(--ease-out) 0.90s forwards;
      width: 0;
      transform: translateX(-50%);
    }
    @keyframes lineGrow {
      to { width: 100%; }
    }

    /* ====== EXAMPLE SHOWCASE ====== */
    .showcase-section {
      width: 100%;
      max-width: 480px;
      margin-bottom: 32px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 1.0s forwards;
    }
    .showcase-container {
      position: relative;
      overflow: hidden;
    }
    .showcase-panel {
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 300ms ease, transform 300ms ease;
      transform: translateY(4px);
    }
    .showcase-panel:first-child {
      position: static;
    }
    .showcase-panel.active {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .showcase-question {
      font-family: var(--font-sans);
      font-size: 13px;
      color: var(--text3);
      margin-bottom: 12px;
      text-align: center;
    }
    .showcase-cards {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .showcase-card {
      flex: 1;
      padding: 8px 10px;
      background: rgba(255,255,255,0.6);
      border: 1px solid rgba(245,192,192,0.25);
      border-radius: 6px;
      text-align: center;
    }
    .showcase-card-label {
      display: block;
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--text3);
      margin-bottom: 4px;
    }
    .showcase-card-value {
      display: block;
      font-family: var(--font-mono);
      font-size: 12px;
      font-weight: 700;
    }
    .showcase-card-green { color: #10B981; }
    .showcase-card-red { color: #EF4444; }

    /* Bar chart */
    .showcase-chart-bars {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .showcase-bar-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .showcase-bar-label {
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text2);
      min-width: 80px;
      text-align: right;
    }
    .showcase-bar-track {
      flex: 1;
      height: 18px;
      background: rgba(0,0,0,0.04);
      border-radius: 4px;
      overflow: hidden;
    }
    .showcase-bar-fill {
      height: 100%;
      border-radius: 4px;
      width: 0;
      transition: width 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    }
    .showcase-bar-green { background: linear-gradient(90deg, #10B981, #34D399); }
    .showcase-bar-red { background: linear-gradient(90deg, #EF4444, #F87171); }

    /* Line chart */
    .showcase-chart-line {
      height: 90px;
      border: 1px solid rgba(245,192,192,0.2);
      border-radius: 6px;
      background: rgba(255,255,255,0.4);
      overflow: hidden;
    }
    .showcase-chart-line svg {
      width: 100%;
      height: 100%;
    }
    .showcase-line {
      stroke-dasharray: 500;
      stroke-dashoffset: 500;
    }
    .showcase-panel.active .showcase-line {
      animation: showcaseLineDraw 1.2s ease forwards;
    }
    @keyframes showcaseLineDraw {
      to { stroke-dashoffset: 0; }
    }

    /* Histogram */
    .showcase-chart-histogram {
      display: flex;
      align-items: flex-end;
      gap: 3px;
      height: 80px;
      padding: 0 4px;
    }
    .showcase-histogram-bar {
      flex: 1;
      background: rgba(210,145,150,0.7);
      border-radius: 2px 2px 0 0;
      height: var(--bar-height);
      transform: scaleY(0);
      transform-origin: bottom;
      transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
    }
    .showcase-panel.active .showcase-histogram-bar {
      transform: scaleY(1);
    }
    .showcase-histogram-bar:nth-child(1) { transition-delay: 0ms; }
    .showcase-histogram-bar:nth-child(2) { transition-delay: 30ms; }
    .showcase-histogram-bar:nth-child(3) { transition-delay: 60ms; }
    .showcase-histogram-bar:nth-child(4) { transition-delay: 90ms; }
    .showcase-histogram-bar:nth-child(5) { transition-delay: 120ms; }
    .showcase-histogram-bar:nth-child(6) { transition-delay: 150ms; }
    .showcase-histogram-bar:nth-child(7) { transition-delay: 180ms; }
    .showcase-histogram-bar:nth-child(8) { transition-delay: 210ms; }
    .showcase-histogram-bar:nth-child(9) { transition-delay: 240ms; }
    .showcase-histogram-bar:nth-child(10) { transition-delay: 270ms; }
    .showcase-histogram-bar:nth-child(11) { transition-delay: 300ms; }
    .showcase-histogram-bar:nth-child(12) { transition-delay: 330ms; }
    .showcase-histogram-bar:nth-child(13) { transition-delay: 360ms; }
    .showcase-histogram-bar:nth-child(14) { transition-delay: 390ms; }
    .showcase-histogram-bar:nth-child(15) { transition-delay: 420ms; }
    .showcase-histogram-peak { background: #10B981; }

    /* Showcase dots + labels */
    .showcase-dots {
      display: flex;
      gap: 6px;
      justify-content: center;
      margin-top: 16px;
    }
    .showcase-dot {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--text3);
      background: transparent;
      border: 1px solid rgba(245, 192, 192, 0.35);
      border-radius: 12px;
      padding: 4px 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 0.6;
    }
    .showcase-dot:hover {
      opacity: 0.9;
      border-color: var(--rose);
    }
    .showcase-dot.active {
      background: rgba(245, 192, 192, 0.2);
      border-color: var(--rose);
      color: var(--text);
      opacity: 1;
    }
    .showcase-realtime {
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text3);
      opacity: 0.6;
      letter-spacing: 0.5px;
      margin-top: 12px;
      text-align: center;
    }
    .showcase-domain-hint {
      font-family: var(--font-sans);
      font-size: 12px;
      color: var(--text3);
      opacity: 0.5;
      margin-top: 6px;
      text-align: center;
    }

    /* ====== OPUS CALLOUT ====== */
    .opus-callout {
      padding: 60px 24px;
      display: flex;
      justify-content: center;
      text-align: center;
    }
    .opus-callout-inner {
      max-width: 640px;
      padding: 32px 28px;
      background: rgba(255,255,255,0.6);
      border: 1px solid rgba(245,192,192,0.25);
      border-radius: 12px;
    }
    .opus-badge {
      font-family: var(--font-mono);
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #fff;
      background: #2563EB;
      padding: 3px 10px;
      border-radius: 4px;
      display: inline-block;
      margin-bottom: 16px;
    }
    .opus-headline {
      font-family: var(--font-pixel);
      font-size: clamp(1.2rem, 2.5vw, 1.5rem);
      color: var(--text);
      letter-spacing: 0.03em;
      margin-bottom: 20px;
    }
    .opus-list {
      text-align: left;
      list-style: decimal;
      padding-left: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .opus-list li {
      font-family: var(--font-sans);
      font-size: 14px;
      color: var(--text3);
      line-height: 1.6;
    }
    .opus-list li strong {
      color: var(--text);
      font-weight: 600;
    }

    /* ====== SCREENSHOT CAROUSEL ====== */
    .screenshot-section {
      padding: 40px 24px;
      text-align: center;
    }
    .screenshot-carousel {
      position: relative;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      aspect-ratio: 16 / 10;
      overflow: hidden;
      border: 1px solid rgba(245, 192, 192, 0.28);
      box-shadow: 0 4px 20px rgba(227, 178, 179, 0.10);
      border-radius: 12px;
      background: #F5F0F0;
    }
    .screenshot-carousel .screenshot-img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      transition: opacity 0.6s ease;
      opacity: 0;
    }
    .screenshot-carousel .screenshot-img.active {
      opacity: 1;
    }
    .screenshot-dots {
      display: flex;
      gap: 6px;
      justify-content: center;
      margin-top: 12px;
    }
    .screenshot-dot {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--text3);
      background: transparent;
      border: 1px solid rgba(245, 192, 192, 0.35);
      border-radius: 12px;
      padding: 4px 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 0.6;
    }
    .screenshot-dot:hover {
      opacity: 0.9;
      border-color: var(--rose);
    }
    .screenshot-dot.active {
      background: rgba(245, 192, 192, 0.2);
      border-color: var(--rose);
      color: var(--text);
      opacity: 1;
    }
    .screenshot-label {
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text3);
      margin-top: 8px;
      letter-spacing: 0.02em;
    }

    /* ====== AUDIENCE LINE ====== */
    .audience-line {
      font-family: var(--font-sans);
      font-size: 1.1rem;
      color: var(--text3);
      text-align: center;
      max-width: 560px;
      margin: 0 auto;
      padding: 40px 24px;
      line-height: 1.7;
    }

    /* ====== DESCRIPTION ====== */
    .description {
      font-family: var(--font-sans);
      font-size: 15px;
      line-height: 1.7;
      color: var(--text3);
      max-width: 380px;
      margin-bottom: 24px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 1.5s forwards;
    }
    .description strong {
      color: var(--text2);
      font-weight: 600;
    }

    /* ====== CASCADE SECTION (Data → Simulation → Decision) ====== */
    .cascade-section {
      position: relative;
      z-index: 1;
      padding: 40px 24px 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .cascade-container {
      display: flex;
      align-items: center;
      gap: 16px;
      max-width: 720px;
      width: 100%;
      justify-content: center;
    }

    .cascade-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .cascade-canvas {
      display: block;
      width: 180px;
      height: 140px;
      border-radius: 8px;
      border: 1px solid rgba(227, 178, 179, 0.35);
      background: rgba(255, 255, 255, 0.55);
      box-shadow: 0 2px 12px rgba(227, 178, 179, 0.08);
    }

    .cascade-label {
      font-family: var(--font-mono);
      font-size: 13px;
      font-weight: 600;
      color: var(--text2);
      letter-spacing: 0.02em;
    }

    .cascade-arrow {
      font-family: var(--font-mono);
      font-size: 22px;
      color: var(--text2);
      opacity: 0.5;
      margin-bottom: 28px;
    }

    @media (max-width: 768px) {
      .cascade-container {
        flex-direction: column;
        gap: 8px;
      }
      .cascade-canvas {
        width: 140px;
        height: 110px;
      }
      .cascade-arrow {
        transform: rotate(90deg);
        margin-bottom: 0;
      }
    }

    /* ====== FEATURE HIGHLIGHT ====== */
    .feature-highlight {
      position: relative; z-index: 1;
      padding: 60px 24px;
      display: flex; justify-content: center;
      text-align: center;
    }
    .feature-highlight-inner { max-width: 520px; }
    .feature-highlight-badge {
      font-family: var(--font-mono); font-size: 10px; font-weight: 600;
      text-transform: uppercase; letter-spacing: 0.1em;
      color: #10B981; background: rgba(16,185,129,0.08);
      padding: 3px 10px; border-radius: 4px;
      display: inline-block; margin-bottom: 16px;
    }
    .feature-highlight-headline {
      font-family: 'Geist Pixel Triangle', monospace;
      font-size: clamp(1.4rem, 3vw, 1.75rem);
      color: #14141C; letter-spacing: 0.03em; margin-bottom: 12px;
    }
    .feature-highlight-desc {
      font-size: 15px; color: #786065; line-height: 1.6; margin-bottom: 28px;
    }
    .feature-highlight-example {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 16px 20px;
      background: rgba(255,255,255,0.6);
      border: 1px solid rgba(245,192,192,0.25);
      border-radius: 8px;
      max-width: 480px;
      margin: 0 auto;
    }
    .feature-example-q {
      font-size: 13px; font-weight: 500; color: #14141C; font-style: italic;
    }
    .feature-example-a {
      font-family: 'Geist Mono', monospace; font-size: 12px;
      font-weight: 600; color: #2563EB;
    }

    /* ====== SCROLL SECTIONS ====== */
    .proof-section {
      position: relative;
      z-index: 1;
      padding: 100px 24px 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .proof-headline {
      font-family: var(--font-pixel);
      font-size: clamp(1.4rem, 3vw, 1.75rem);
      font-weight: 400;
      color: var(--text);
      letter-spacing: 0.03em;
      margin-bottom: 56px;
    }

    .stat-grid {
      display: flex;
      gap: 40px;
      max-width: 800px;
      width: 100%;
      justify-content: center;
    }

    .stat-block {
      flex: 1;
      max-width: 220px;
      text-align: left;
      padding-left: 16px;
      border-left: 2px solid var(--rose);
      position: relative;
    }

    .stat-label {
      font-family: var(--font-mono);
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      margin-bottom: 8px;
    }

    .stat-value {
      font-family: var(--font-sans);
      font-size: 36px;
      font-weight: 700;
      color: var(--text);
      line-height: 1.1;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
      position: relative;
    }

    .stat-desc {
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 400;
      color: var(--text3);
      line-height: 1.5;
    }

    /* Orbiting dot for stat blocks */
    .orbit-dot {
      position: absolute;
      width: 6px;
      height: 6px;
      background: var(--rose);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .orbit-dot.active {
      opacity: 1;
    }

    /* ====== FINAL CTA SECTION ====== */
    .cta-section {
      position: relative;
      z-index: 1;
      padding: 80px 24px 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 16px;
    }

    .cta-headline {
      font-family: var(--font-pixel);
      font-size: clamp(1.8rem, 4vw, 2.25rem);
      font-weight: 400;
      color: var(--text);
      letter-spacing: 0.03em;
    }

    .cta-subhead {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      color: var(--text3);
      margin-bottom: 4px;
    }

    .cta-body {
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 400;
      color: var(--text3);
      margin-bottom: 12px;
    }

    .credits {
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text3);
      letter-spacing: 0.04em;
      margin-top: 24px;
      max-width: 480px;
      margin-left: auto;
      margin-right: auto;
    }
    .credits span {
      display: block;
      margin-top: 4px;
    }

    /* ====== SCROLL REVEAL ====== */
    .reveal {
      opacity: 0;
      transform: translateY(24px);
      transition: opacity 0.4s var(--ease-out), transform 0.4s var(--ease-out);
    }
    .reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* ====== ANIMATIONS ====== */
    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(16px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to   { opacity: 1; }
    }

    /* ====== FADE-OUT TRANSITION ====== */
    body.fade-out {
      animation: pageFadeOut 0.4s ease forwards;
    }
    @keyframes pageFadeOut {
      to { opacity: 0; transform: scale(0.98); }
    }

    /* ====== REDUCED MOTION ====== */
    @media (prefers-reduced-motion: reduce) {
      .reveal {
        opacity: 1 !important;
        transform: none !important;
        transition: none !important;
      }
    }

    /* ====== RESPONSIVE ====== */
    @media (max-width: 640px) {
      .brand { font-size: clamp(3rem, 12vw, 5rem); }
      .tagline { font-size: 17px; }
      .cta { padding: 14px 28px; font-size: 15px; }
      .cta-static { padding: 18px 36px; font-size: 16px; }

      .stat-grid {
        flex-direction: column;
        gap: 28px;
        align-items: center;
      }
      .stat-block {
        max-width: 300px;
        width: 100%;
      }
      .stat-value { font-size: 28px; }

      /* Showcase: stack all panels on mobile */
      .showcase-container { height: auto; }
      .showcase-panel {
        position: static !important;
        opacity: 1 !important;
        pointer-events: auto !important;
        transform: none !important;
        margin-bottom: 24px;
      }
      .showcase-dots { display: none; }
      .showcase-cards { flex-direction: column; }
    }

    /* ====== REDUCED MOTION ====== */
    @media (prefers-reduced-motion: reduce) {
      .showcase-container { height: auto; }
      .showcase-panel {
        position: static !important;
        opacity: 1 !important;
        pointer-events: auto !important;
        transform: none !important;
      }
      .showcase-panel + .showcase-panel { margin-top: 32px; }
      .showcase-dots { display: none; }
      .showcase-bar-fill { transition: none; }
      .showcase-panel polyline { stroke-dashoffset: 0 !important; animation: none !important; }
      .showcase-histogram-bar { transform: scaleY(1) !important; transition: none !important; }
      .screenshot-carousel .screenshot-img { transition: none; }
    }
  </style>
</head>
<body>

  <!-- Interactive dot grid canvas (MUST be first child for z-index ordering) -->
  <canvas id="dot-grid-canvas"></canvas>

  <!-- Ambient glow -->
  <div class="glow"></div>

  <!-- Top bar -->
  <div class="top-bar">
    Built with <span class="highlight">Claude</span> &middot; <span class="highlight">Anthropic</span> Hackathon 2026
  </div>

  <!-- ====== SECTION 1: HERO ====== -->
  <section class="hero-section">
    <div class="hero">

      <!-- Prism SVG icon -->
      <div class="prism-icon">
        <svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="prismGrad" x1="0%" y1="100%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#2563eb"/>
              <stop offset="50%" stop-color="#E3B2B3"/>
              <stop offset="100%" stop-color="#10B981"/>
            </linearGradient>
          </defs>
          <path d="M28 6 L50 46 L6 46 Z" stroke="url(#prismGrad)" stroke-width="2.5" fill="none" stroke-linejoin="round"/>
        </svg>
      </div>

      <!-- Brand -->
      <h1 class="brand">PRISMA</h1>

      <!-- Tagline -->
      <p class="tagline">See what happens before it happens.</p>

      <!-- Subtitle -->
      <p class="subtitle">Upload your spreadsheet. Test every decision before you commit.</p>

      <!-- CTA (dark, with particle canvas) -->
      <a href="app.html" class="cta cta-nav" id="cta-hero">
        <canvas class="cta-canvas" id="hero-canvas"></canvas>
        <span class="cta-content">
          Make Your First Decision
          <svg class="cta-arrow" width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </span>
      </a>

      <!-- Trust line -->
      <p class="trust-line">Free. No signup. Simulations run in your browser.</p>

      <!-- Accent line -->
      <div class="accent-line"></div>

      <!-- ====== EXAMPLE SHOWCASE (3 ops examples, auto-rotating) ====== -->
      <div class="showcase-section" aria-roledescription="carousel" aria-label="Decision examples">
        <div class="showcase-container">
          <!-- Panel 1: Staffing Decision (BAR chart) — in flow, establishes height -->
          <div class="showcase-panel active" data-panel="0" aria-live="polite">
            <p class="showcase-question"><em>&ldquo;Should I hire two more drivers before Q3?&rdquo;</em></p>
            <div class="showcase-cards">
              <div class="showcase-card showcase-card-positive">
                <span class="showcase-card-label">Hire in Q2</span>
                <span class="showcase-card-value showcase-card-green">+&euro;3,100/mo</span>
              </div>
              <div class="showcase-card showcase-card-positive">
                <span class="showcase-card-label">Raise base pay</span>
                <span class="showcase-card-value showcase-card-green">+&euro;1,200/mo</span>
              </div>
              <div class="showcase-card showcase-card-negative">
                <span class="showcase-card-label">Do nothing</span>
                <span class="showcase-card-value showcase-card-red">&minus;&euro;4,800 by Q4</span>
              </div>
            </div>
            <div class="showcase-chart showcase-chart-bars">
              <div class="showcase-bar-row">
                <span class="showcase-bar-label">Hire in Q2</span>
                <div class="showcase-bar-track"><div class="showcase-bar-fill showcase-bar-green" data-width="82"></div></div>
              </div>
              <div class="showcase-bar-row">
                <span class="showcase-bar-label">Raise pay</span>
                <div class="showcase-bar-track"><div class="showcase-bar-fill showcase-bar-green" data-width="45"></div></div>
              </div>
              <div class="showcase-bar-row">
                <span class="showcase-bar-label">Do nothing</span>
                <div class="showcase-bar-track"><div class="showcase-bar-fill showcase-bar-red" data-width="65"></div></div>
              </div>
            </div>
          </div>

          <!-- Panel 2: Route Optimization (LINE chart) -->
          <div class="showcase-panel" data-panel="1">
            <p class="showcase-question"><em>&ldquo;Which zones are bleeding delivery time?&rdquo;</em></p>
            <div class="showcase-cards">
              <div class="showcase-card showcase-card-positive">
                <span class="showcase-card-label">Reassign Zone C</span>
                <span class="showcase-card-value showcase-card-green">&minus;18 min avg</span>
              </div>
              <div class="showcase-card showcase-card-positive">
                <span class="showcase-card-label">Add evening shift</span>
                <span class="showcase-card-value showcase-card-green">&minus;12 min avg</span>
              </div>
              <div class="showcase-card showcase-card-negative">
                <span class="showcase-card-label">Split Zone A</span>
                <span class="showcase-card-value showcase-card-red">&minus;7 min avg</span>
              </div>
            </div>
            <div class="showcase-chart showcase-chart-line">
              <svg viewBox="0 0 300 150" preserveAspectRatio="none">
                <line x1="0" y1="30" x2="300" y2="30" stroke="rgba(245,192,192,0.2)" stroke-width="1"/>
                <line x1="0" y1="75" x2="300" y2="75" stroke="rgba(245,192,192,0.2)" stroke-width="1"/>
                <line x1="0" y1="120" x2="300" y2="120" stroke="rgba(245,192,192,0.2)" stroke-width="1"/>
                <polyline class="showcase-line"
                  fill="none" stroke="#2563EB" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"
                  points="15,110 50,95 85,100 120,80 155,55 190,45 225,60 260,35 285,30"/>
              </svg>
            </div>
          </div>

          <!-- Panel 3: Cost Control (HISTOGRAM) -->
          <div class="showcase-panel" data-panel="2">
            <p class="showcase-question"><em>&ldquo;Can we cut overtime without losing SLA?&rdquo;</em></p>
            <div class="showcase-cards">
              <div class="showcase-card showcase-card-positive">
                <span class="showcase-card-label">Cap at 10h/week</span>
                <span class="showcase-card-value showcase-card-green">89% SLA</span>
              </div>
              <div class="showcase-card showcase-card-positive">
                <span class="showcase-card-label">Rotate weekends</span>
                <span class="showcase-card-value showcase-card-green">94% SLA</span>
              </div>
              <div class="showcase-card showcase-card-negative">
                <span class="showcase-card-label">No change</span>
                <span class="showcase-card-value showcase-card-red">SLA drops to 81%</span>
              </div>
            </div>
            <div class="showcase-chart showcase-chart-histogram">
              <div class="showcase-histogram-bar" style="--bar-height: 15%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 25%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 35%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 50%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 65%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 80%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 95%"></div>
              <div class="showcase-histogram-bar showcase-histogram-peak" style="--bar-height: 100%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 90%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 75%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 55%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 40%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 30%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 20%"></div>
              <div class="showcase-histogram-bar" style="--bar-height: 15%"></div>
            </div>
          </div>
        </div>

        <div class="showcase-dots">
          <button class="showcase-dot active" aria-label="Staffing decision example">Staffing</button>
          <button class="showcase-dot" aria-label="Route optimization example">Routes</button>
          <button class="showcase-dot" aria-label="Cost control example">Overtime</button>
        </div>

        <p class="showcase-realtime">1,000 scenarios &middot; computed in real-time</p>
        <p class="showcase-domain-hint"><em>Shown: logistics operations. Works for any domain with spreadsheet data &mdash; healthcare, marketing, finance, HR.</em></p>
      </div>

      <!-- Description -->
      <p class="description">
        Any spreadsheet. Hidden patterns in seconds. Every option tested. One clear answer.
      </p>

    </div>
  </section>

  <!-- ====== CASCADE: Data → Simulation → Decision ====== -->
  <section class="cascade-section reveal">
    <div class="cascade-container">
      <div class="cascade-step">
        <canvas class="cascade-canvas" id="cascade-1"></canvas>
        <span class="cascade-label">Your data</span>
      </div>
      <span class="cascade-arrow">&rarr;</span>
      <div class="cascade-step">
        <canvas class="cascade-canvas" id="cascade-2"></canvas>
        <span class="cascade-label">1,000 futures</span>
      </div>
      <span class="cascade-arrow">&rarr;</span>
      <div class="cascade-step">
        <canvas class="cascade-canvas" id="cascade-3"></canvas>
        <span class="cascade-label">Your answer</span>
      </div>
    </div>
  </section>

  <!-- ====== FEATURE: Chat with your data ====== -->
  <section class="feature-highlight reveal">
    <div class="feature-highlight-inner">
      <h2 class="feature-highlight-headline">Chat with your data.</h2>
      <p class="feature-highlight-desc">
        Probability. Risk. Recommendation. In seconds.
      </p>
      <div class="feature-highlight-example">
        <span class="feature-example-q">"What happens if I cut the fleet from 40 to 35 drivers?"</span>
        <span class="feature-example-a">72% SLA holds &middot; 28% Mon/Thu risk &middot; &euro;4,200/mo saved &middot; Cut to 37 first.</span>
      </div>
    </div>
  </section>

  <!-- ====== SECTION 2: THE PROOF ====== -->
  <section class="proof-section">
    <h2 class="proof-headline reveal">What your spreadsheet can&rsquo;t show you.</h2>
    <div class="stat-grid">
      <div class="stat-block reveal">
        <div class="stat-label">Patterns</div>
        <div class="stat-value">&euro;47K in overtime</div>
        <div class="stat-desc">PRISMA shows 60% came from 4 drivers on Tue/Thu shifts &mdash; and it started 6 weeks ago.</div>
      </div>
      <div class="stat-block reveal">
        <div class="stat-label">Possibilities</div>
        <div class="stat-value" data-count-target="1000"><span class="count-number">1,000</span> futures</div>
        <div class="stat-desc">Your spreadsheet has last month&rsquo;s numbers. PRISMA runs 1,000 futures and shows which decisions survive the worst case.</div>
      </div>
      <div class="stat-block reveal">
        <div class="stat-label">Risks</div>
        <div class="stat-value">SLA at 94%</div>
        <div class="stat-desc">PRISMA flags that 3 top drivers show burnout signals &mdash; if any one leaves, SLA drops to 86% within 2 weeks.</div>
      </div>
    </div>
  </section>

  <!-- ====== OPUS 4.6 CALLOUT ====== -->
  <section class="opus-callout reveal" style="position: relative; z-index: 1;">
    <div class="opus-callout-inner">
      <span class="opus-badge">Powered by Claude Opus 4.6</span>
      <h2 class="opus-headline">What Claude Opus 4.6 Does Inside PRISMA</h2>
      <ol class="opus-list">
        <li>Reads your data and builds a causal model &mdash; which variables drive which outcomes, including hidden feedback loops</li>
        <li>Structures Monte Carlo simulations &mdash; defines distributions, scenarios, and outcome formulas from your actual data</li>
        <li>Classifies risk using the Taleb framework: <strong>FRAGILE</strong> / <strong>ROBUST</strong> / <strong>ANTIFRAGILE</strong></li>
        <li>Runs sensitivity analysis to find the 1&ndash;2 variables that actually matter, then delivers a confidence-scored recommendation</li>
      </ol>
    </div>
  </section>

  <!-- ====== PRODUCT SCREENSHOTS ====== -->
  <section class="screenshot-section reveal" style="position: relative; z-index: 1;">
    <div class="screenshot-carousel">
      <img src="/images/prisma-screenshot-1.webp"
           alt="Prisma app showing Monte Carlo simulation results with staffing optimization verdict"
           width="2560" height="1396"
           loading="lazy" decoding="async"
           class="screenshot-img active">
      <img src="/images/prisma-screenshot-2.webp"
           alt="Prisma app showing data analysis dashboard with charts and KPI cards"
           width="2560" height="1651"
           loading="lazy" decoding="async"
           class="screenshot-img">
    </div>
    <div class="screenshot-dots">
      <button class="screenshot-dot active" aria-label="Simulation view">Simulation</button>
      <button class="screenshot-dot" aria-label="Data analysis view">Analysis</button>
    </div>
    <p class="screenshot-label">Live product. Real data. Actual simulation output.</p>
  </section>

  <!-- ====== AUDIENCE LINE ====== -->
  <p class="audience-line reveal" style="position: relative; z-index: 1;">
    Built for ops managers who make high-stakes calls on bad data.
    And for data scientists who want the same rigor in 60 seconds instead of 60 minutes.
  </p>

  <!-- ====== SECTION 3: FINAL CTA ====== -->
  <section class="cta-section">
    <h2 class="cta-headline reveal">Every decision is a bet.</h2>
    <p class="cta-subhead reveal">See the odds first.</p>
    <p class="cta-body reveal">Free. No signup. Just answers.</p>
    <a href="app.html" class="cta cta-static cta-nav reveal" id="cta-footer">
      <canvas class="cta-canvas" id="footer-canvas"></canvas>
      <span class="cta-content">
        Make Your First Decision
        <svg class="cta-arrow" width="16" height="16" viewBox="0 0 16 16" fill="none">
          <path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </span>
    </a>
    <div class="credits reveal">
      <strong>Muzaffer Hizel</strong><br>
      From warehouse floors to HQ boardrooms &mdash; scaled operations from single-city launches
      to multi-region P&amp;Ls across Big Tech and unicorn startups (Seed to Series C).<br>
      Built the dashboards, designed the processes, made the calls.<br>
      Now building the tool I wished I had.
      <span>Built with Claude (Opus 4.6) &middot; Anthropic Hackathon 2026</span>
    </div>
  </section>

  <!-- Button particle system -->
  <script src="/js/button-particles.js"></script>

  <script>
    // ====== GLOBAL ANIMATION REGISTRY (for cleanup on page exit) ======
    window.__prismaAnimations = [];

    // ====== SCROLL REVEAL ======
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.15 });

    document.querySelectorAll('.reveal').forEach((el) => {
      const siblings = Array.from(el.parentElement.querySelectorAll('.reveal'));
      const idx = siblings.indexOf(el);
      el.style.transitionDelay = (idx * 0.08) + 's';
      observer.observe(el);
    });

    // ====== CTA: FADE OUT + CLEANUP ======
    document.querySelectorAll('.cta-nav').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        const href = this.getAttribute('href');
        // Cancel all canvas animations (slots >= 2 = setInterval, rest = rAF)
        window.__prismaAnimations.forEach((id, idx) => {
          if (idx >= 2) clearInterval(id);
          else cancelAnimationFrame(id);
        });
        window.__prismaAnimations = [];
        // Stop button particle instances
        if (window.__prismaParticles) {
          window.__prismaParticles.forEach(p => p.stop());
        }
        document.body.classList.add('fade-out');
        setTimeout(() => { window.location.href = href; }, 400);
      });
    });

    // ====== INTERACTIVE DOT GRID ======
    (function() {
      const canvas = document.getElementById('dot-grid-canvas');
      if (!canvas) return;

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const ctx = canvas.getContext('2d');
      const spacing = 20;
      let w, h, cols, rows;
      let mouseX = -1000, mouseY = -1000;
      let frameCount = 0;
      let dirtyDots = new Set();

      // Per-dot state (only used for dots that become interactive)
      let dotMap = {};

      function getDot(idx) {
        if (!dotMap[idx]) {
          dotMap[idx] = { s: 1, r: 245, g: 192, b: 192, a: 0.85 };
        }
        return dotMap[idx];
      }

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        cols = Math.ceil(w / spacing) + 1;
        rows = Math.ceil(h / spacing) + 1;

        if (prefersReducedMotion) drawStatic();
      }

      function drawStatic() {
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            ctx.beginPath();
            ctx.arc(i * spacing, j * spacing, 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function render() {
        frameCount++;
        // Throttle to ~30fps
        if (frameCount % 2 !== 0) {
          const id = requestAnimationFrame(render);
          window.__prismaAnimations[0] = id;
          return;
        }

        ctx.clearRect(0, 0, w, h);

        // Compute interactive bounding box
        const radius = 120;
        const iMinCol = Math.max(0, Math.floor((mouseX - radius) / spacing) - 1);
        const iMaxCol = Math.min(cols - 1, Math.ceil((mouseX + radius) / spacing) + 1);
        const iMinRow = Math.max(0, Math.floor((mouseY - radius) / spacing) - 1);
        const iMaxRow = Math.min(rows - 1, Math.ceil((mouseY + radius) / spacing) + 1);

        // Draw all default dots (batch single fillStyle)
        ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            const idx = i * rows + j;
            // Skip if in interactive zone or dirty
            if (i >= iMinCol && i <= iMaxCol && j >= iMinRow && j <= iMaxRow) continue;
            if (dirtyDots.has(idx)) continue;
            ctx.beginPath();
            ctx.arc(i * spacing, j * spacing, 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Process interactive zone dots
        for (let i = iMinCol; i <= iMaxCol; i++) {
          for (let j = iMinRow; j <= iMaxRow; j++) {
            if (i < 0 || j < 0 || i >= cols || j >= rows) continue;
            const x = i * spacing;
            const y = j * spacing;
            const dx = mouseX - x;
            const dy = mouseY - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const idx = i * rows + j;
            const dot = getDot(idx);

            if (dist < radius) {
              dirtyDots.add(idx);
              const factor = Math.pow(1 - dist / radius, 2);
              const ts = 1 + factor * 2.2;
              let tr, tg, tb, ta;
              if (dist < 45) {
                tr = 180; tg = 120; tb = 125; ta = 1.0;
              } else {
                tr = 220; tg = 165; tb = 170; ta = 1.0;
              }
              dot.s += (ts - dot.s) * 0.08;
              dot.r += (tr - dot.r) * 0.08;
              dot.g += (tg - dot.g) * 0.08;
              dot.b += (tb - dot.b) * 0.08;
              dot.a += (ta - dot.a) * 0.08;
            } else {
              dot.s += (1 - dot.s) * 0.04;
              dot.r += (245 - dot.r) * 0.04;
              dot.g += (192 - dot.g) * 0.04;
              dot.b += (192 - dot.b) * 0.04;
              dot.a += (0.85 - dot.a) * 0.04;
              if (Math.abs(dot.s - 1) < 0.02) {
                dot.s = 1; dot.r = 245; dot.g = 192; dot.b = 192; dot.a = 0.85;
                dirtyDots.delete(idx);
                ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, Math.PI * 2);
                ctx.fill();
                continue;
              }
            }

            ctx.beginPath();
            ctx.arc(x, y, dot.s, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + (dot.r | 0) + ',' + (dot.g | 0) + ',' + (dot.b | 0) + ',' + dot.a.toFixed(2) + ')';
            ctx.fill();
          }
        }

        // Process dirty dots outside interactive zone (returning to default)
        dirtyDots.forEach(idx => {
          const i = Math.floor(idx / rows);
          const j = idx % rows;
          if (i >= iMinCol && i <= iMaxCol && j >= iMinRow && j <= iMaxRow) return;
          const dot = getDot(idx);
          dot.s += (1 - dot.s) * 0.04;
          dot.r += (245 - dot.r) * 0.04;
          dot.g += (192 - dot.g) * 0.04;
          dot.b += (192 - dot.b) * 0.04;
          dot.a += (0.85 - dot.a) * 0.04;

          if (Math.abs(dot.s - 1) < 0.02) {
            dot.s = 1; dot.r = 245; dot.g = 192; dot.b = 192; dot.a = 0.85;
            dirtyDots.delete(idx);
            delete dotMap[idx];
            ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
            ctx.beginPath();
            ctx.arc(i * spacing, j * spacing, 1, 0, Math.PI * 2);
            ctx.fill();
            return;
          }

          ctx.beginPath();
          ctx.arc(i * spacing, j * spacing, dot.s, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(' + (dot.r | 0) + ',' + (dot.g | 0) + ',' + (dot.b | 0) + ',' + dot.a.toFixed(2) + ')';
          ctx.fill();
        });

        const id = requestAnimationFrame(render);
        window.__prismaAnimations[0] = id;
      }

      window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      }, { passive: true });

      document.addEventListener('mouseleave', () => {
        mouseX = -1000;
        mouseY = -1000;
      });

      window.addEventListener('resize', resize);
      resize();

      if (!prefersReducedMotion) {
        const id = requestAnimationFrame(render);
        window.__prismaAnimations[0] = id;
      }
    })();

    // ====== CASCADE ANIMATION (3 canvases, looping) ======
    (function() {
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const section = document.querySelector('.cascade-section');
      const canvases = [
        document.getElementById('cascade-1'),
        document.getElementById('cascade-2'),
        document.getElementById('cascade-3')
      ];
      if (!canvases[0]) return;

      const dpr = window.devicePixelRatio || 1;
      const ctxs = canvases.map(c => {
        const ctx = c.getContext('2d');
        c.width = 180 * dpr;
        c.height = 140 * dpr;
        ctx.scale(dpr, dpr);
        return ctx;
      });
      const cw = 180, ch = 140;
      const dotCount = 45;
      const roseColor = [245, 192, 192];
      const greenColor = [16, 185, 129];

      // Gaussian for bell curve
      function gaussian(x, mean, std) {
        return Math.exp(-Math.pow(x - mean, 2) / (2 * std * std));
      }

      // Generate dot sets
      const dots = [];
      for (let i = 0; i < dotCount; i++) {
        const t = i / (dotCount - 1);
        // Random scatter positions
        const scatterX = Math.random() * (cw - 20) + 10;
        const scatterY = Math.random() * (ch - 20) + 10;
        // Histogram positions (columns)
        const numCols = 8;
        const col = Math.floor(Math.random() * numCols);
        const colX = 15 + col * ((cw - 30) / (numCols - 1));
        const colHeight = gaussian(col, numCols / 2, numCols / 4) * (ch * 0.7);
        const colY = ch - 15 - Math.random() * colHeight;
        // Bell curve positions
        const bellX = 10 + t * (cw - 20);
        const bellHeight = gaussian(bellX, cw / 2, cw / 5) * (ch * 0.75);
        const bellY = ch - 15 - bellHeight + (Math.random() - 0.5) * 6;
        // Is this a peak dot? (near center of bell curve)
        const isPeak = Math.abs(bellX - cw / 2) < 20 && i % 8 === 0;

        dots.push({
          scatter: { x: scatterX, y: scatterY },
          histo: { x: colX, y: colY },
          bell: { x: bellX, y: bellY },
          isPeak: isPeak,
          x: scatterX, y: scatterY,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5
        });
      }

      // Phases: scatter(2s) → organize(1.5s) → converge(1.5s) → hold(3s) → reset(0.5s)
      const phaseDurations = [2000, 1500, 1500, 3000, 500];
      const totalCycle = phaseDurations.reduce((a, b) => a + b, 0);
      let startTime = 0;
      let isVisible = false;
      let animId = null;

      function easeInOut(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      }

      function lerp(a, b, t) { return a + (b - a) * t; }

      function getPhase(elapsed) {
        let t = elapsed % totalCycle;
        let acc = 0;
        for (let i = 0; i < phaseDurations.length; i++) {
          if (t < acc + phaseDurations[i]) {
            return { phase: i, progress: (t - acc) / phaseDurations[i] };
          }
          acc += phaseDurations[i];
        }
        return { phase: 0, progress: 0 };
      }

      function drawDots(ctx, phase, progress) {
        ctx.clearRect(0, 0, cw, ch);

        dots.forEach(d => {
          let tx, ty;
          let isGreen = false;

          if (phase === 0) {
            // Scatter: drift around scatter positions
            tx = d.scatter.x + Math.sin(Date.now() * 0.001 + d.scatter.x) * 3;
            ty = d.scatter.y + Math.cos(Date.now() * 0.0012 + d.scatter.y) * 3;
          } else if (phase === 1) {
            // Transition: scatter → histogram
            const e = easeInOut(progress);
            tx = lerp(d.scatter.x, d.histo.x, e);
            ty = lerp(d.scatter.y, d.histo.y, e);
          } else if (phase === 2) {
            // Transition: histogram → bell curve
            const e = easeInOut(progress);
            tx = lerp(d.histo.x, d.bell.x, e);
            ty = lerp(d.histo.y, d.bell.y, e);
            if (d.isPeak && progress > 0.7) isGreen = true;
          } else if (phase === 3) {
            // Hold: bell curve
            tx = d.bell.x + Math.sin(Date.now() * 0.0005 + d.bell.x) * 0.5;
            ty = d.bell.y + Math.cos(Date.now() * 0.0006 + d.bell.y) * 0.5;
            if (d.isPeak) isGreen = true;
          } else {
            // Reset: bell → scatter
            const e = easeInOut(progress);
            tx = lerp(d.bell.x, d.scatter.x, e);
            ty = lerp(d.bell.y, d.scatter.y, e);
          }

          ctx.beginPath();
          ctx.arc(tx, ty, isGreen ? 3.5 : 2.5, 0, Math.PI * 2);
          if (isGreen) {
            ctx.fillStyle = 'rgba(16, 185, 129, 0.8)';
          } else {
            ctx.fillStyle = 'rgba(210, 145, 150, 0.9)';
          }
          ctx.fill();
        });

        // Draw checkmark in canvas 3 during hold phase
        if (phase === 3) {
          ctx.save();
          ctx.strokeStyle = 'rgba(16, 185, 129, 0.7)';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(cw / 2 - 6, 18);
          ctx.lineTo(cw / 2 - 1, 23);
          ctx.lineTo(cw / 2 + 8, 12);
          ctx.stroke();
          ctx.restore();
        }
      }

      function animate() {
        if (!isVisible) return;
        const elapsed = Date.now() - startTime;
        const { phase, progress } = getPhase(elapsed);

        // Canvas 1: always scatter
        drawDots(ctxs[0], 0, 0);
        // Canvas 2: scatter → histogram → hold → reset
        if (phase <= 0) {
          drawDots(ctxs[1], 0, 0);
        } else if (phase === 1) {
          drawDots(ctxs[1], 1, progress);
        } else if (phase === 4) {
          // Reset: histogram → scatter
          ctxs[1].clearRect(0, 0, cw, ch);
          const e4 = easeInOut(progress);
          dots.forEach(d => {
            ctxs[1].beginPath();
            ctxs[1].arc(lerp(d.histo.x, d.scatter.x, e4), lerp(d.histo.y, d.scatter.y, e4), 2.5, 0, Math.PI * 2);
            ctxs[1].fillStyle = 'rgba(245, 192, 192, 0.7)';
            ctxs[1].fill();
          });
        } else {
          // Hold histogram with gentle jitter
          ctxs[1].clearRect(0, 0, cw, ch);
          dots.forEach(d => {
            ctxs[1].beginPath();
            const jx = d.histo.x + Math.sin(Date.now() * 0.0008 + d.histo.x) * 1;
            const jy = d.histo.y + Math.cos(Date.now() * 0.001 + d.histo.y) * 1;
            ctxs[1].arc(jx, jy, 2.5, 0, Math.PI * 2);
            ctxs[1].fillStyle = 'rgba(245, 192, 192, 0.7)';
            ctxs[1].fill();
          });
        }
        // Canvas 3: scatter → bell curve (direct, no histogram step)
        if (phase <= 1) {
          drawDots(ctxs[2], 0, 0);
        } else if (phase === 2) {
          // Custom: scatter → bell directly
          ctxs[2].clearRect(0, 0, cw, ch);
          const e2 = easeInOut(progress);
          dots.forEach(d => {
            const tx = lerp(d.scatter.x, d.bell.x, e2);
            const ty = lerp(d.scatter.y, d.bell.y, e2);
            const isGreen = d.isPeak && progress > 0.7;
            ctxs[2].beginPath();
            ctxs[2].arc(tx, ty, isGreen ? 3.5 : 2.5, 0, Math.PI * 2);
            ctxs[2].fillStyle = isGreen ? 'rgba(16, 185, 129, 0.95)' : 'rgba(210, 145, 150, 0.9)';
            ctxs[2].fill();
          });
        } else if (phase === 3) {
          drawDots(ctxs[2], 3, progress);
        } else {
          drawDots(ctxs[2], 4, progress);
        }

        animId = requestAnimationFrame(animate);
        window.__prismaAnimations[1] = animId;
      }

      // Reduced motion: show final state
      if (prefersReducedMotion) {
        // Canvas 1: scatter
        drawDots(ctxs[0], 0, 0);
        // Canvas 2: histogram
        ctxs[1].clearRect(0, 0, cw, ch);
        dots.forEach(d => {
          ctxs[1].beginPath();
          ctxs[1].arc(d.histo.x, d.histo.y, 2.5, 0, Math.PI * 2);
          ctxs[1].fillStyle = 'rgba(245, 192, 192, 0.7)';
          ctxs[1].fill();
        });
        // Canvas 3: bell curve
        drawDots(ctxs[2], 3, 0);
        return;
      }

      // IntersectionObserver: pause/resume cascade
      const cascadeObs = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          if (e.isIntersecting && !isVisible) {
            isVisible = true;
            startTime = Date.now();
            animate();
          } else if (!e.isIntersecting) {
            isVisible = false;
            if (animId) cancelAnimationFrame(animId);
          }
        });
      }, { threshold: 0 });
      cascadeObs.observe(section);
    })();

    // ====== PROOF SECTION: COUNT-UP + ORBITING DOT ======
    (function() {
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) return;

      const statBlocks = document.querySelectorAll('.stat-block');
      let played = false;

      function easeOutExpo(t) {
        return t >= 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }

      function animateBlock(block, delay) {
        const valueEl = block.querySelector('.stat-value');
        const target = valueEl.getAttribute('data-count-target');
        const isNumeric = target !== null;
        const targetNum = isNumeric ? parseInt(target, 10) : 0;
        const numberSpan = valueEl.querySelector('.count-number');

        // Create orbiting dot
        const dot = document.createElement('div');
        dot.className = 'orbit-dot';
        valueEl.appendChild(dot);

        setTimeout(() => {
          dot.classList.add('active');
          const duration = 1200;
          const orbitRadius = 20;
          const start = Date.now();
          const revolutions = 2.5;

          function tick() {
            const elapsed = Date.now() - start;
            const t = Math.min(elapsed / duration, 1);
            const eased = easeOutExpo(t);

            // Update counter if numeric
            if (isNumeric && numberSpan) {
              const val = Math.round(eased * targetNum);
              numberSpan.textContent = val.toLocaleString();
            }

            // Orbit
            const angle = t * revolutions * Math.PI * 2;
            const ox = Math.cos(angle) * orbitRadius * (1 - t * 0.3);
            const oy = Math.sin(angle) * orbitRadius * (1 - t * 0.3);
            dot.style.left = (ox + 10) + 'px';
            dot.style.top = (oy - 8) + 'px';

            if (t < 1) {
              requestAnimationFrame(tick);
            } else {
              // Snap and fade
              if (isNumeric && numberSpan) {
                numberSpan.textContent = targetNum.toLocaleString();
              }
              dot.style.transition = 'opacity 0.3s ease';
              dot.style.opacity = '0';
              setTimeout(() => dot.remove(), 300);
            }
          }
          requestAnimationFrame(tick);
        }, delay);
      }

      const proofObs = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          if (e.isIntersecting && !played) {
            played = true;
            statBlocks.forEach((block, i) => animateBlock(block, i * 200));
            proofObs.disconnect();
          }
        });
      }, { threshold: 0.5 });

      document.querySelectorAll('.stat-block').forEach(b => proofObs.observe(b));
    })();

    // ====== EXAMPLE SHOWCASE (3 ops examples, auto-rotating) ======
    (function() {
      var prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      var container = document.querySelector('.showcase-container');
      if (!container) return;

      var panels = container.querySelectorAll('.showcase-panel');
      var dots = document.querySelectorAll('.showcase-dot');
      if (panels.length < 2) return;

      var currentIdx = 0;
      var intervalId = null;
      var paused = false;
      var mobileQuery = window.matchMedia('(max-width: 640px)');

      function activatePanel(idx) {
        // Deactivate all
        panels.forEach(function(p) { p.classList.remove('active'); });
        dots.forEach(function(d) { d.classList.remove('active'); });

        // Reset line SVG animation (re-trigger by removing/adding class)
        var oldPanel = panels[currentIdx];
        var oldLine = oldPanel.querySelector('.showcase-line');
        if (oldLine) {
          oldLine.style.strokeDashoffset = '500';
        }

        // Activate new
        panels[idx].classList.add('active');
        dots[idx].classList.add('active');

        // Trigger line draw animation
        var newLine = panels[idx].querySelector('.showcase-line');
        if (newLine) {
          newLine.style.strokeDashoffset = '500';
          // Force reflow to restart animation
          void newLine.offsetWidth;
          newLine.style.strokeDashoffset = '';
        }

        // Animate bar fills for bar chart panel
        var bars = panels[idx].querySelectorAll('.showcase-bar-fill');
        bars.forEach(function(bar) {
          bar.style.width = '0';
          void bar.offsetWidth;
          bar.style.width = bar.getAttribute('data-width') + '%';
        });

        currentIdx = idx;
      }

      function nextPanel() {
        activatePanel((currentIdx + 1) % panels.length);
      }

      function startRotation() {
        if (prefersReducedMotion || mobileQuery.matches) return;
        stopRotation();
        intervalId = setInterval(nextPanel, 4000);
        window.__prismaAnimations[2] = intervalId;
      }

      function stopRotation() {
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
          window.__prismaAnimations[2] = null;
        }
      }

      // Dot click handlers
      dots.forEach(function(dot, i) {
        dot.addEventListener('click', function() {
          activatePanel(i);
          startRotation(); // Reset timer
        });
      });

      // Pause on hover + focus (WCAG 2.2.2)
      var section = document.querySelector('.showcase-section');
      section.addEventListener('mouseenter', function() { paused = true; stopRotation(); });
      section.addEventListener('mouseleave', function() { paused = false; startRotation(); });
      section.addEventListener('focusin', function() { paused = true; stopRotation(); });
      section.addEventListener('focusout', function() { paused = false; startRotation(); });

      // IntersectionObserver: only rotate when visible
      var obs = new IntersectionObserver(function(entries) {
        entries.forEach(function(e) {
          if (e.isIntersecting && !paused) {
            startRotation();
          } else if (!e.isIntersecting) {
            stopRotation();
          }
        });
      }, { threshold: 0 });
      obs.observe(container);

      // Mobile: disable rotation, all panels visible via CSS
      mobileQuery.addEventListener('change', function() {
        if (mobileQuery.matches) {
          stopRotation();
        }
      });

      // Animate initial bar fills after entrance animation
      setTimeout(function() {
        var bars = panels[0].querySelectorAll('.showcase-bar-fill');
        bars.forEach(function(bar) {
          bar.style.width = bar.getAttribute('data-width') + '%';
        });
      }, 1200);

      // Reduced motion: show all panels, no rotation
      if (prefersReducedMotion) {
        panels.forEach(function(p) { p.classList.add('active'); });
        // Set bar widths immediately
        container.querySelectorAll('.showcase-bar-fill').forEach(function(bar) {
          bar.style.width = bar.getAttribute('data-width') + '%';
        });
      }
    })();

    // ====== SCREENSHOT CAROUSEL (2 images, auto-rotating) ======
    (function() {
      var prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      var carousel = document.querySelector('.screenshot-carousel');
      if (!carousel) return;

      var imgs = carousel.querySelectorAll('.screenshot-img');
      var dots = document.querySelectorAll('.screenshot-dot');
      if (imgs.length < 2) return;

      var currentIdx = 0;
      var intervalId = null;
      var paused = false;

      function showSlide(idx) {
        imgs.forEach(function(img, i) {
          img.classList.toggle('active', i === idx);
        });
        dots.forEach(function(dot, i) {
          dot.classList.toggle('active', i === idx);
        });
        currentIdx = idx;
      }

      function nextSlide() {
        showSlide((currentIdx + 1) % imgs.length);
      }

      function startRotation() {
        if (prefersReducedMotion) return;
        stopRotation();
        intervalId = setInterval(nextSlide, 5000);
        window.__prismaAnimations[3] = intervalId;
      }

      function stopRotation() {
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
          window.__prismaAnimations[3] = null;
        }
      }

      // Dot click handlers
      dots.forEach(function(dot, i) {
        dot.addEventListener('click', function() {
          showSlide(i);
          startRotation();
        });
      });

      // Pause on hover + focus (WCAG 2.2.2)
      var section = document.querySelector('.screenshot-section');
      section.addEventListener('mouseenter', function() { paused = true; stopRotation(); });
      section.addEventListener('mouseleave', function() { paused = false; startRotation(); });
      section.addEventListener('focusin', function() { paused = true; stopRotation(); });
      section.addEventListener('focusout', function() { paused = false; startRotation(); });

      // IntersectionObserver: only rotate when visible
      var obs = new IntersectionObserver(function(entries) {
        entries.forEach(function(e) {
          if (e.isIntersecting && !paused) {
            startRotation();
          } else if (!e.isIntersecting) {
            stopRotation();
          }
        });
      }, { threshold: 0 });
      obs.observe(carousel);

      // Reduced motion: show first image only, no rotation
      if (prefersReducedMotion) {
        showSlide(0);
      }
    })();
  </script>

</body>
</html>
