<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PRISMA — See what happens before it happens.</title>
  <meta name="description" content="Upload your data. Prisma finds what you're missing, then simulates every path forward — so you decide with evidence, not instinct.">

  <!-- Preload pixel font -->
  <link rel="preload" href="/fonts/GeistPixel-Triangle.woff2" as="font" type="font/woff2" crossorigin>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&display=swap" rel="stylesheet">

  <style>
    /* ====== FONT ====== */
    @font-face {
      font-family: 'Geist Pixel Triangle';
      src: url('/fonts/GeistPixel-Triangle.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    /* ====== VARIABLES ====== */
    :root {
      --bg: #F5F0F0;
      --text: #14141C;
      --text2: #43394c;
      --text3: #786065;
      --accent: #2563eb;
      --accent-dark: #1d4ed8;
      --rose: #E3B2B3;
      --font-pixel: 'Geist Pixel Triangle', monospace;
      --font-sans: 'Geist', system-ui, -apple-system, sans-serif;
      --font-mono: 'Geist Mono', 'SF Mono', monospace;
      --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
    }

    /* ====== RESET ====== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html { height: 100%; scroll-behavior: smooth; }
    body { min-height: 100%; }

    body {
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      position: relative;
    }

    /* ====== INTERACTIVE DOT GRID (canvas, replaces body::before) ====== */
    #dot-grid-canvas {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }

    /* ====== GLOW BEHIND HERO ====== */
    .glow {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }
    .glow::before {
      content: '';
      position: absolute;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      width: 600px;
      height: 500px;
      background:
        radial-gradient(ellipse at center, rgba(37, 99, 235, 0.06) 0%, transparent 70%),
        radial-gradient(ellipse at 60% 40%, rgba(16, 185, 129, 0.04) 0%, transparent 60%);
      filter: blur(40px);
    }

    /* ====== TOP BAR ====== */
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      text-align: center;
      padding: 12px 24px;
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text3);
      letter-spacing: 0.02em;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0s forwards;
    }
    .top-bar .highlight {
      color: var(--accent);
      font-weight: 600;
    }

    /* ====== HERO SECTION ====== */
    .hero-section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 1;
    }

    .hero {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 0;
      max-width: 640px;
      padding: 0 24px;
    }

    /* ====== PRISM ICON ====== */
    .prism-icon {
      margin-bottom: 24px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.15s forwards;
    }
    .prism-icon svg {
      filter: drop-shadow(0 0 12px rgba(37, 99, 235, 0.15));
      animation: prismPulse 4s ease-in-out infinite;
    }
    @keyframes prismPulse {
      0%, 100% { filter: drop-shadow(0 0 12px rgba(37, 99, 235, 0.15)); }
      50%      { filter: drop-shadow(0 0 24px rgba(37, 99, 235, 0.25)); }
    }

    /* ====== BRAND NAME ====== */
    .brand {
      font-family: var(--font-pixel);
      font-size: clamp(4rem, 8vw, 7rem);
      font-weight: 400;
      letter-spacing: 0.06em;
      color: var(--text);
      line-height: 1;
      margin-bottom: 12px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.30s forwards;
    }

    /* ====== TAGLINE ====== */
    .tagline {
      font-family: var(--font-sans);
      font-size: 20px;
      font-weight: 600;
      color: var(--text2);
      margin-bottom: 12px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.50s forwards;
    }

    /* ====== SUBTITLE ====== */
    .subtitle {
      font-family: var(--font-sans);
      font-size: 15px;
      font-weight: 400;
      color: var(--text3);
      line-height: 1.6;
      margin-bottom: 32px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.60s forwards;
    }

    /* ====== CTA BUTTON (dark, with canvas particles) ====== */
    .cta {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 18px 40px;
      background: #1A1520;
      color: #F5F0F0;
      border: 1px solid rgba(245, 192, 192, 0.18);
      border-radius: 6px;
      font-family: var(--font-sans);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.3s ease, border-color 0.3s ease;
      text-decoration: none;
      margin-bottom: 40px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 0.75s forwards;
      overflow: hidden;
    }
    .cta:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(26, 21, 32, 0.15);
      border-color: rgba(245, 240, 240, 0.35);
    }
    .cta:active { transform: translateY(0); }
    .cta:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 4px;
    }

    .cta-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .cta-content {
      position: relative;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .cta-arrow {
      transition: transform 0.3s ease;
      opacity: 0.85;
    }
    .cta:hover .cta-arrow {
      transform: translateX(4px);
      opacity: 1;
    }

    /* Static CTA (no hero animation, used in scroll sections) */
    .cta-static {
      opacity: 1;
      animation: none;
      margin-bottom: 0;
      padding: 22px 52px;
      font-size: 18px;
    }

    /* ====== ACCENT LINE ====== */
    .accent-line {
      width: 200px;
      height: 1px;
      margin-bottom: 36px;
      opacity: 0;
      animation: fadeUp 0.5s var(--ease-out) 0.90s forwards;
      position: relative;
    }
    .accent-line::after {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      height: 1px;
      background: linear-gradient(90deg, var(--accent), var(--rose), #10B981);
      animation: lineGrow 0.8s var(--ease-out) 0.90s forwards;
      width: 0;
      transform: translateX(-50%);
    }
    @keyframes lineGrow {
      to { width: 100%; }
    }

    /* ====== MINI SIM PREVIEW ====== */
    .mini-sim {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 32px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 1.2s forwards;
    }
    .sim-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .sim-label {
      font-family: var(--font-mono);
      font-size: 12px;
      font-weight: 500;
      color: var(--text2);
      min-width: 100px;
      text-align: right;
    }
    .sim-bar-track {
      flex: 1;
      height: 22px;
      background: rgba(0, 0, 0, 0.04);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }
    .sim-bar-fill {
      height: 100%;
      border-radius: 4px;
      width: 0;
    }
    .sim-row:nth-child(1) .sim-bar-fill {
      background: linear-gradient(90deg, #2563eb, #3b82f6);
      animation: barGrow1 0.8s var(--ease-out) 1.4s forwards;
    }
    .sim-row:nth-child(2) .sim-bar-fill {
      background: linear-gradient(90deg, #7C3AED, #8B5CF6);
      animation: barGrow2 0.8s var(--ease-out) 1.5s forwards;
    }
    .sim-row:nth-child(3) .sim-bar-fill {
      background: linear-gradient(90deg, #EF4444, #F87171);
      animation: barGrow3 0.8s var(--ease-out) 1.6s forwards;
    }
    @keyframes barGrow1 { to { width: 78%; } }
    @keyframes barGrow2 { to { width: 42%; } }
    @keyframes barGrow3 { to { width: 62%; } }

    .sim-value {
      font-family: var(--font-mono);
      font-size: 12px;
      font-weight: 700;
      min-width: 60px;
      text-align: left;
      opacity: 0;
    }
    .sim-row:nth-child(1) .sim-value {
      color: #10B981;
      animation: fadeIn 0.4s ease 1.8s forwards;
    }
    .sim-row:nth-child(2) .sim-value {
      color: #10B981;
      animation: fadeIn 0.4s ease 1.9s forwards;
    }
    .sim-row:nth-child(3) .sim-value {
      color: #EF4444;
      animation: fadeIn 0.4s ease 2.0s forwards;
    }

    /* ====== DESCRIPTION ====== */
    .description {
      font-family: var(--font-sans);
      font-size: 15px;
      line-height: 1.7;
      color: var(--text3);
      max-width: 380px;
      margin-bottom: 24px;
      opacity: 0;
      animation: fadeUp 0.6s var(--ease-out) 1.5s forwards;
    }
    .description strong {
      color: var(--text2);
      font-weight: 600;
    }

    /* ====== CASCADE SECTION (Data → Simulation → Decision) ====== */
    .cascade-section {
      position: relative;
      z-index: 1;
      padding: 40px 24px 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .cascade-container {
      display: flex;
      align-items: center;
      gap: 16px;
      max-width: 720px;
      width: 100%;
      justify-content: center;
    }

    .cascade-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .cascade-canvas {
      display: block;
      width: 180px;
      height: 140px;
      border-radius: 8px;
      border: 1px solid rgba(245, 192, 192, 0.18);
      background: rgba(245, 240, 240, 0.4);
    }

    .cascade-label {
      font-family: var(--font-mono);
      font-size: 12px;
      font-weight: 500;
      color: var(--text3);
      letter-spacing: 0.02em;
    }

    .cascade-arrow {
      font-family: var(--font-mono);
      font-size: 20px;
      color: var(--text3);
      opacity: 0.4;
      margin-bottom: 28px;
    }

    @media (max-width: 768px) {
      .cascade-container {
        flex-direction: column;
        gap: 8px;
      }
      .cascade-canvas {
        width: 140px;
        height: 110px;
      }
      .cascade-arrow {
        transform: rotate(90deg);
        margin-bottom: 0;
      }
    }

    /* ====== SCROLL SECTIONS ====== */
    .proof-section {
      position: relative;
      z-index: 1;
      padding: 100px 24px 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .proof-headline {
      font-family: var(--font-pixel);
      font-size: clamp(1.4rem, 3vw, 1.75rem);
      font-weight: 400;
      color: var(--text);
      letter-spacing: 0.03em;
      margin-bottom: 56px;
    }

    .stat-grid {
      display: flex;
      gap: 40px;
      max-width: 800px;
      width: 100%;
      justify-content: center;
    }

    .stat-block {
      flex: 1;
      max-width: 220px;
      text-align: left;
      padding-left: 16px;
      border-left: 2px solid var(--rose);
      position: relative;
    }

    .stat-label {
      font-family: var(--font-mono);
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      margin-bottom: 8px;
    }

    .stat-value {
      font-family: var(--font-sans);
      font-size: 36px;
      font-weight: 700;
      color: var(--text);
      line-height: 1.1;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
      position: relative;
    }

    .stat-desc {
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 400;
      color: var(--text3);
      line-height: 1.5;
    }

    /* Orbiting dot for stat blocks */
    .orbit-dot {
      position: absolute;
      width: 6px;
      height: 6px;
      background: var(--rose);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .orbit-dot.active {
      opacity: 1;
    }

    /* ====== FINAL CTA SECTION ====== */
    .cta-section {
      position: relative;
      z-index: 1;
      padding: 80px 24px 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 16px;
    }

    .cta-headline {
      font-family: var(--font-pixel);
      font-size: clamp(1.8rem, 4vw, 2.25rem);
      font-weight: 400;
      color: var(--text);
      letter-spacing: 0.03em;
    }

    .cta-subhead {
      font-family: var(--font-sans);
      font-size: 18px;
      font-weight: 400;
      color: var(--text3);
      margin-bottom: 4px;
    }

    .cta-body {
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 400;
      color: var(--text3);
      margin-bottom: 12px;
    }

    .credits {
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--text3);
      letter-spacing: 0.04em;
      margin-top: 24px;
    }
    .credits span {
      display: block;
      margin-top: 4px;
    }

    /* ====== SCROLL REVEAL ====== */
    .reveal {
      opacity: 0;
      transform: translateY(24px);
      transition: opacity 0.4s var(--ease-out), transform 0.4s var(--ease-out);
    }
    .reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* ====== ANIMATIONS ====== */
    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(16px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to   { opacity: 1; }
    }

    /* ====== FADE-OUT TRANSITION ====== */
    body.fade-out {
      animation: pageFadeOut 0.4s ease forwards;
    }
    @keyframes pageFadeOut {
      to { opacity: 0; transform: scale(0.98); }
    }

    /* ====== REDUCED MOTION ====== */
    @media (prefers-reduced-motion: reduce) {
      .reveal {
        opacity: 1 !important;
        transform: none !important;
        transition: none !important;
      }
    }

    /* ====== RESPONSIVE ====== */
    @media (max-width: 640px) {
      .brand { font-size: clamp(3rem, 12vw, 5rem); }
      .tagline { font-size: 17px; }
      .mini-sim { max-width: 320px; }
      .sim-label { min-width: 72px; font-size: 11px; }
      .cta { padding: 14px 28px; font-size: 15px; }
      .cta-static { padding: 18px 36px; font-size: 16px; }

      .stat-grid {
        flex-direction: column;
        gap: 28px;
        align-items: center;
      }
      .stat-block {
        max-width: 300px;
        width: 100%;
      }
      .stat-value { font-size: 28px; }
    }
  </style>
</head>
<body>

  <!-- Interactive dot grid canvas (MUST be first child for z-index ordering) -->
  <canvas id="dot-grid-canvas"></canvas>

  <!-- Ambient glow -->
  <div class="glow"></div>

  <!-- Top bar -->
  <div class="top-bar">
    Built with <span class="highlight">Claude</span> &middot; <span class="highlight">Anthropic</span> Hackathon 2026
  </div>

  <!-- ====== SECTION 1: HERO ====== -->
  <section class="hero-section">
    <div class="hero">

      <!-- Prism SVG icon -->
      <div class="prism-icon">
        <svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="prismGrad" x1="0%" y1="100%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#2563eb"/>
              <stop offset="50%" stop-color="#E3B2B3"/>
              <stop offset="100%" stop-color="#10B981"/>
            </linearGradient>
          </defs>
          <path d="M28 6 L50 46 L6 46 Z" stroke="url(#prismGrad)" stroke-width="2.5" fill="none" stroke-linejoin="round"/>
        </svg>
      </div>

      <!-- Brand -->
      <h1 class="brand">PRISMA</h1>

      <!-- Tagline -->
      <p class="tagline">See what happens before it happens.</p>

      <!-- Subtitle -->
      <p class="subtitle">Upload your data. Prisma finds what you&rsquo;re missing &mdash;<br>then simulates what happens next.</p>

      <!-- CTA (dark, with particle canvas) -->
      <a href="app.html" class="cta cta-nav" id="cta-hero">
        <canvas class="cta-canvas" id="hero-canvas"></canvas>
        <span class="cta-content">
          Make Your First Decision
          <svg class="cta-arrow" width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </span>
      </a>

      <!-- Accent line -->
      <div class="accent-line"></div>

      <!-- Mini simulation bars -->
      <div class="mini-sim">
        <div class="sim-row">
          <span class="sim-label">Hire in Q2</span>
          <div class="sim-bar-track"><div class="sim-bar-fill"></div></div>
          <span class="sim-value">+&euro;3,100</span>
        </div>
        <div class="sim-row">
          <span class="sim-label">Raise prices</span>
          <div class="sim-bar-track"><div class="sim-bar-fill"></div></div>
          <span class="sim-value">+&euro;1,200</span>
        </div>
        <div class="sim-row">
          <span class="sim-label">Expand market</span>
          <div class="sim-bar-track"><div class="sim-bar-fill"></div></div>
          <span class="sim-value">&minus;&euro;1,400</span>
        </div>
      </div>

      <!-- Description -->
      <p class="description">
        Drop any spreadsheet &mdash; sales, hiring, costs, forecasts.
        <strong>Prisma</strong> surfaces hidden risks and opportunities in seconds,
        then lets you simulate every option. Thousands of scenarios. One clear answer.
      </p>

    </div>
  </section>

  <!-- ====== CASCADE: Data → Simulation → Decision ====== -->
  <section class="cascade-section reveal">
    <div class="cascade-container">
      <div class="cascade-step">
        <canvas class="cascade-canvas" id="cascade-1"></canvas>
        <span class="cascade-label">Your data</span>
      </div>
      <span class="cascade-arrow">&rarr;</span>
      <div class="cascade-step">
        <canvas class="cascade-canvas" id="cascade-2"></canvas>
        <span class="cascade-label">1,000 simulations</span>
      </div>
      <span class="cascade-arrow">&rarr;</span>
      <div class="cascade-step">
        <canvas class="cascade-canvas" id="cascade-3"></canvas>
        <span class="cascade-label">Your answer</span>
      </div>
    </div>
  </section>

  <!-- ====== SECTION 2: THE PROOF ====== -->
  <section class="proof-section">
    <h2 class="proof-headline reveal">One upload. Three insights. A thousand scenarios.</h2>
    <div class="stat-grid">
      <div class="stat-block reveal">
        <div class="stat-label">Patterns</div>
        <div class="stat-value">Found in seconds</div>
        <div class="stat-desc">What your spreadsheet never showed you</div>
      </div>
      <div class="stat-block reveal">
        <div class="stat-label">Simulations</div>
        <div class="stat-value" data-count-target="1000"><span class="count-number">1,000</span> scenarios</div>
        <div class="stat-desc">Every path forward, tested at once</div>
      </div>
      <div class="stat-block reveal">
        <div class="stat-label">Risks</div>
        <div class="stat-value">Flagged automatically</div>
        <div class="stat-desc">The downside you&rsquo;d discover too late</div>
      </div>
    </div>
  </section>

  <!-- ====== SECTION 3: FINAL CTA ====== -->
  <section class="cta-section">
    <h2 class="cta-headline reveal">Every decision is a bet.</h2>
    <p class="cta-subhead reveal">See the odds first.</p>
    <p class="cta-body reveal">Free. No signup. Drop a CSV and see what happens.</p>
    <a href="app.html" class="cta cta-static cta-nav reveal" id="cta-footer">
      <canvas class="cta-canvas" id="footer-canvas"></canvas>
      <span class="cta-content">
        Make Your First Decision
        <svg class="cta-arrow" width="16" height="16" viewBox="0 0 16 16" fill="none">
          <path d="M6 3L11 8L6 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </span>
    </a>
    <div class="credits reveal">
      Muzaffer Hizel &middot; 2026
      <span>Built with Claude &middot; Anthropic Hackathon 2026</span>
    </div>
  </section>

  <!-- Button particle system -->
  <script src="/js/button-particles.js"></script>

  <script>
    // ====== GLOBAL ANIMATION REGISTRY (for cleanup on page exit) ======
    window.__prismaAnimations = [];

    // ====== SCROLL REVEAL ======
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.15 });

    document.querySelectorAll('.reveal').forEach((el) => {
      const siblings = Array.from(el.parentElement.querySelectorAll('.reveal'));
      const idx = siblings.indexOf(el);
      el.style.transitionDelay = (idx * 0.08) + 's';
      observer.observe(el);
    });

    // ====== CTA: FADE OUT + CLEANUP ======
    document.querySelectorAll('.cta-nav').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.preventDefault();
        const href = this.getAttribute('href');
        // Cancel all canvas animations
        window.__prismaAnimations.forEach(id => cancelAnimationFrame(id));
        window.__prismaAnimations = [];
        // Stop button particle instances
        if (window.__prismaParticles) {
          window.__prismaParticles.forEach(p => p.stop());
        }
        document.body.classList.add('fade-out');
        setTimeout(() => { window.location.href = href; }, 400);
      });
    });

    // ====== INTERACTIVE DOT GRID ======
    (function() {
      const canvas = document.getElementById('dot-grid-canvas');
      if (!canvas) return;

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const ctx = canvas.getContext('2d');
      const spacing = 20;
      let w, h, cols, rows;
      let mouseX = -1000, mouseY = -1000;
      let frameCount = 0;
      let dirtyDots = new Set();

      // Per-dot state (only used for dots that become interactive)
      let dotMap = {};

      function getDot(idx) {
        if (!dotMap[idx]) {
          dotMap[idx] = { s: 1, r: 245, g: 192, b: 192, a: 0.85 };
        }
        return dotMap[idx];
      }

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        cols = Math.ceil(w / spacing) + 1;
        rows = Math.ceil(h / spacing) + 1;

        if (prefersReducedMotion) drawStatic();
      }

      function drawStatic() {
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            ctx.beginPath();
            ctx.arc(i * spacing, j * spacing, 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function render() {
        frameCount++;
        // Throttle to ~30fps
        if (frameCount % 2 !== 0) {
          const id = requestAnimationFrame(render);
          window.__prismaAnimations[0] = id;
          return;
        }

        ctx.clearRect(0, 0, w, h);

        // Compute interactive bounding box
        const radius = 120;
        const iMinCol = Math.max(0, Math.floor((mouseX - radius) / spacing) - 1);
        const iMaxCol = Math.min(cols - 1, Math.ceil((mouseX + radius) / spacing) + 1);
        const iMinRow = Math.max(0, Math.floor((mouseY - radius) / spacing) - 1);
        const iMaxRow = Math.min(rows - 1, Math.ceil((mouseY + radius) / spacing) + 1);

        // Draw all default dots (batch single fillStyle)
        ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < rows; j++) {
            const idx = i * rows + j;
            // Skip if in interactive zone or dirty
            if (i >= iMinCol && i <= iMaxCol && j >= iMinRow && j <= iMaxRow) continue;
            if (dirtyDots.has(idx)) continue;
            ctx.beginPath();
            ctx.arc(i * spacing, j * spacing, 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Process interactive zone dots
        for (let i = iMinCol; i <= iMaxCol; i++) {
          for (let j = iMinRow; j <= iMaxRow; j++) {
            if (i < 0 || j < 0 || i >= cols || j >= rows) continue;
            const x = i * spacing;
            const y = j * spacing;
            const dx = mouseX - x;
            const dy = mouseY - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const idx = i * rows + j;
            const dot = getDot(idx);

            if (dist < radius) {
              dirtyDots.add(idx);
              const factor = Math.pow(1 - dist / radius, 2);
              const ts = 1 + factor * 1.5;
              let tr, tg, tb, ta;
              if (dist < 40) {
                tr = 195; tg = 142; tb = 143; ta = 0.9;
              } else {
                tr = 245; tg = 192; tb = 192; ta = 1.0;
              }
              dot.s += (ts - dot.s) * 0.08;
              dot.r += (tr - dot.r) * 0.08;
              dot.g += (tg - dot.g) * 0.08;
              dot.b += (tb - dot.b) * 0.08;
              dot.a += (ta - dot.a) * 0.08;
            } else {
              dot.s += (1 - dot.s) * 0.04;
              dot.r += (245 - dot.r) * 0.04;
              dot.g += (192 - dot.g) * 0.04;
              dot.b += (192 - dot.b) * 0.04;
              dot.a += (0.85 - dot.a) * 0.04;
              if (Math.abs(dot.s - 1) < 0.02) {
                dot.s = 1; dot.r = 245; dot.g = 192; dot.b = 192; dot.a = 0.85;
                dirtyDots.delete(idx);
                ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, Math.PI * 2);
                ctx.fill();
                continue;
              }
            }

            ctx.beginPath();
            ctx.arc(x, y, dot.s, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + (dot.r | 0) + ',' + (dot.g | 0) + ',' + (dot.b | 0) + ',' + dot.a.toFixed(2) + ')';
            ctx.fill();
          }
        }

        // Process dirty dots outside interactive zone (returning to default)
        dirtyDots.forEach(idx => {
          const i = Math.floor(idx / rows);
          const j = idx % rows;
          if (i >= iMinCol && i <= iMaxCol && j >= iMinRow && j <= iMaxRow) return;
          const dot = getDot(idx);
          dot.s += (1 - dot.s) * 0.04;
          dot.r += (245 - dot.r) * 0.04;
          dot.g += (192 - dot.g) * 0.04;
          dot.b += (192 - dot.b) * 0.04;
          dot.a += (0.85 - dot.a) * 0.04;

          if (Math.abs(dot.s - 1) < 0.02) {
            dot.s = 1; dot.r = 245; dot.g = 192; dot.b = 192; dot.a = 0.85;
            dirtyDots.delete(idx);
            delete dotMap[idx];
            ctx.fillStyle = 'rgba(245, 192, 192, 0.85)';
            ctx.beginPath();
            ctx.arc(i * spacing, j * spacing, 1, 0, Math.PI * 2);
            ctx.fill();
            return;
          }

          ctx.beginPath();
          ctx.arc(i * spacing, j * spacing, dot.s, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(' + (dot.r | 0) + ',' + (dot.g | 0) + ',' + (dot.b | 0) + ',' + dot.a.toFixed(2) + ')';
          ctx.fill();
        });

        const id = requestAnimationFrame(render);
        window.__prismaAnimations[0] = id;
      }

      window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      }, { passive: true });

      document.addEventListener('mouseleave', () => {
        mouseX = -1000;
        mouseY = -1000;
      });

      window.addEventListener('resize', resize);
      resize();

      if (!prefersReducedMotion) {
        const id = requestAnimationFrame(render);
        window.__prismaAnimations[0] = id;
      }
    })();

    // ====== CASCADE ANIMATION (3 canvases, looping) ======
    (function() {
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const section = document.querySelector('.cascade-section');
      const canvases = [
        document.getElementById('cascade-1'),
        document.getElementById('cascade-2'),
        document.getElementById('cascade-3')
      ];
      if (!canvases[0]) return;

      const dpr = window.devicePixelRatio || 1;
      const ctxs = canvases.map(c => {
        const ctx = c.getContext('2d');
        c.width = 180 * dpr;
        c.height = 140 * dpr;
        ctx.scale(dpr, dpr);
        return ctx;
      });
      const cw = 180, ch = 140;
      const dotCount = 45;
      const roseColor = [245, 192, 192];
      const greenColor = [16, 185, 129];

      // Gaussian for bell curve
      function gaussian(x, mean, std) {
        return Math.exp(-Math.pow(x - mean, 2) / (2 * std * std));
      }

      // Generate dot sets
      const dots = [];
      for (let i = 0; i < dotCount; i++) {
        const t = i / (dotCount - 1);
        // Random scatter positions
        const scatterX = Math.random() * (cw - 20) + 10;
        const scatterY = Math.random() * (ch - 20) + 10;
        // Histogram positions (columns)
        const numCols = 8;
        const col = Math.floor(Math.random() * numCols);
        const colX = 15 + col * ((cw - 30) / (numCols - 1));
        const colHeight = gaussian(col, numCols / 2, numCols / 4) * (ch * 0.7);
        const colY = ch - 15 - Math.random() * colHeight;
        // Bell curve positions
        const bellX = 10 + t * (cw - 20);
        const bellHeight = gaussian(bellX, cw / 2, cw / 5) * (ch * 0.75);
        const bellY = ch - 15 - bellHeight + (Math.random() - 0.5) * 6;
        // Is this a peak dot? (near center of bell curve)
        const isPeak = Math.abs(bellX - cw / 2) < 20 && i % 8 === 0;

        dots.push({
          scatter: { x: scatterX, y: scatterY },
          histo: { x: colX, y: colY },
          bell: { x: bellX, y: bellY },
          isPeak: isPeak,
          x: scatterX, y: scatterY,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5
        });
      }

      // Phases: scatter(2s) → organize(1.5s) → converge(1.5s) → hold(3s) → reset(0.5s)
      const phaseDurations = [2000, 1500, 1500, 3000, 500];
      const totalCycle = phaseDurations.reduce((a, b) => a + b, 0);
      let startTime = 0;
      let isVisible = false;
      let animId = null;

      function easeInOut(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      }

      function lerp(a, b, t) { return a + (b - a) * t; }

      function getPhase(elapsed) {
        let t = elapsed % totalCycle;
        let acc = 0;
        for (let i = 0; i < phaseDurations.length; i++) {
          if (t < acc + phaseDurations[i]) {
            return { phase: i, progress: (t - acc) / phaseDurations[i] };
          }
          acc += phaseDurations[i];
        }
        return { phase: 0, progress: 0 };
      }

      function drawDots(ctx, phase, progress) {
        ctx.clearRect(0, 0, cw, ch);

        dots.forEach(d => {
          let tx, ty;
          let isGreen = false;

          if (phase === 0) {
            // Scatter: drift around scatter positions
            tx = d.scatter.x + Math.sin(Date.now() * 0.001 + d.scatter.x) * 3;
            ty = d.scatter.y + Math.cos(Date.now() * 0.0012 + d.scatter.y) * 3;
          } else if (phase === 1) {
            // Transition: scatter → histogram
            const e = easeInOut(progress);
            tx = lerp(d.scatter.x, d.histo.x, e);
            ty = lerp(d.scatter.y, d.histo.y, e);
          } else if (phase === 2) {
            // Transition: histogram → bell curve
            const e = easeInOut(progress);
            tx = lerp(d.histo.x, d.bell.x, e);
            ty = lerp(d.histo.y, d.bell.y, e);
            if (d.isPeak && progress > 0.7) isGreen = true;
          } else if (phase === 3) {
            // Hold: bell curve
            tx = d.bell.x + Math.sin(Date.now() * 0.0005 + d.bell.x) * 0.5;
            ty = d.bell.y + Math.cos(Date.now() * 0.0006 + d.bell.y) * 0.5;
            if (d.isPeak) isGreen = true;
          } else {
            // Reset: bell → scatter
            const e = easeInOut(progress);
            tx = lerp(d.bell.x, d.scatter.x, e);
            ty = lerp(d.bell.y, d.scatter.y, e);
          }

          ctx.beginPath();
          ctx.arc(tx, ty, isGreen ? 3 : 2, 0, Math.PI * 2);
          if (isGreen) {
            ctx.fillStyle = 'rgba(16, 185, 129, 0.8)';
          } else {
            ctx.fillStyle = 'rgba(245, 192, 192, 0.7)';
          }
          ctx.fill();
        });

        // Draw checkmark in canvas 3 during hold phase
        if (phase === 3) {
          ctx.save();
          ctx.strokeStyle = 'rgba(16, 185, 129, 0.7)';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(cw / 2 - 6, 18);
          ctx.lineTo(cw / 2 - 1, 23);
          ctx.lineTo(cw / 2 + 8, 12);
          ctx.stroke();
          ctx.restore();
        }
      }

      function animate() {
        if (!isVisible) return;
        const elapsed = Date.now() - startTime;
        const { phase, progress } = getPhase(elapsed);

        // Canvas 1: always scatter
        drawDots(ctxs[0], 0, 0);
        // Canvas 2: scatter → histogram → hold → reset
        if (phase <= 0) {
          drawDots(ctxs[1], 0, 0);
        } else if (phase === 1) {
          drawDots(ctxs[1], 1, progress);
        } else if (phase === 4) {
          // Reset: histogram → scatter
          ctxs[1].clearRect(0, 0, cw, ch);
          const e4 = easeInOut(progress);
          dots.forEach(d => {
            ctxs[1].beginPath();
            ctxs[1].arc(lerp(d.histo.x, d.scatter.x, e4), lerp(d.histo.y, d.scatter.y, e4), 2, 0, Math.PI * 2);
            ctxs[1].fillStyle = 'rgba(245, 192, 192, 0.7)';
            ctxs[1].fill();
          });
        } else {
          // Hold histogram with gentle jitter
          ctxs[1].clearRect(0, 0, cw, ch);
          dots.forEach(d => {
            ctxs[1].beginPath();
            const jx = d.histo.x + Math.sin(Date.now() * 0.0008 + d.histo.x) * 1;
            const jy = d.histo.y + Math.cos(Date.now() * 0.001 + d.histo.y) * 1;
            ctxs[1].arc(jx, jy, 2, 0, Math.PI * 2);
            ctxs[1].fillStyle = 'rgba(245, 192, 192, 0.7)';
            ctxs[1].fill();
          });
        }
        // Canvas 3: scatter → bell curve (direct, no histogram step)
        if (phase <= 1) {
          drawDots(ctxs[2], 0, 0);
        } else if (phase === 2) {
          // Custom: scatter → bell directly
          ctxs[2].clearRect(0, 0, cw, ch);
          const e2 = easeInOut(progress);
          dots.forEach(d => {
            const tx = lerp(d.scatter.x, d.bell.x, e2);
            const ty = lerp(d.scatter.y, d.bell.y, e2);
            const isGreen = d.isPeak && progress > 0.7;
            ctxs[2].beginPath();
            ctxs[2].arc(tx, ty, isGreen ? 3 : 2, 0, Math.PI * 2);
            ctxs[2].fillStyle = isGreen ? 'rgba(16, 185, 129, 0.8)' : 'rgba(245, 192, 192, 0.7)';
            ctxs[2].fill();
          });
        } else if (phase === 3) {
          drawDots(ctxs[2], 3, progress);
        } else {
          drawDots(ctxs[2], 4, progress);
        }

        animId = requestAnimationFrame(animate);
        window.__prismaAnimations[1] = animId;
      }

      // Reduced motion: show final state
      if (prefersReducedMotion) {
        // Canvas 1: scatter
        drawDots(ctxs[0], 0, 0);
        // Canvas 2: histogram
        ctxs[1].clearRect(0, 0, cw, ch);
        dots.forEach(d => {
          ctxs[1].beginPath();
          ctxs[1].arc(d.histo.x, d.histo.y, 2, 0, Math.PI * 2);
          ctxs[1].fillStyle = 'rgba(245, 192, 192, 0.7)';
          ctxs[1].fill();
        });
        // Canvas 3: bell curve
        drawDots(ctxs[2], 3, 0);
        return;
      }

      // IntersectionObserver: pause/resume cascade
      const cascadeObs = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          if (e.isIntersecting && !isVisible) {
            isVisible = true;
            startTime = Date.now();
            animate();
          } else if (!e.isIntersecting) {
            isVisible = false;
            if (animId) cancelAnimationFrame(animId);
          }
        });
      }, { threshold: 0 });
      cascadeObs.observe(section);
    })();

    // ====== PROOF SECTION: COUNT-UP + ORBITING DOT ======
    (function() {
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) return;

      const statBlocks = document.querySelectorAll('.stat-block');
      let played = false;

      function easeOutExpo(t) {
        return t >= 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }

      function animateBlock(block, delay) {
        const valueEl = block.querySelector('.stat-value');
        const target = valueEl.getAttribute('data-count-target');
        const isNumeric = target !== null;
        const targetNum = isNumeric ? parseInt(target, 10) : 0;
        const numberSpan = valueEl.querySelector('.count-number');

        // Create orbiting dot
        const dot = document.createElement('div');
        dot.className = 'orbit-dot';
        valueEl.appendChild(dot);

        setTimeout(() => {
          dot.classList.add('active');
          const duration = 1200;
          const orbitRadius = 20;
          const start = Date.now();
          const revolutions = 2.5;

          function tick() {
            const elapsed = Date.now() - start;
            const t = Math.min(elapsed / duration, 1);
            const eased = easeOutExpo(t);

            // Update counter if numeric
            if (isNumeric && numberSpan) {
              const val = Math.round(eased * targetNum);
              numberSpan.textContent = val.toLocaleString();
            }

            // Orbit
            const angle = t * revolutions * Math.PI * 2;
            const ox = Math.cos(angle) * orbitRadius * (1 - t * 0.3);
            const oy = Math.sin(angle) * orbitRadius * (1 - t * 0.3);
            dot.style.left = (ox + 10) + 'px';
            dot.style.top = (oy - 8) + 'px';

            if (t < 1) {
              requestAnimationFrame(tick);
            } else {
              // Snap and fade
              if (isNumeric && numberSpan) {
                numberSpan.textContent = targetNum.toLocaleString();
              }
              dot.style.transition = 'opacity 0.3s ease';
              dot.style.opacity = '0';
              setTimeout(() => dot.remove(), 300);
            }
          }
          requestAnimationFrame(tick);
        }, delay);
      }

      const proofObs = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          if (e.isIntersecting && !played) {
            played = true;
            statBlocks.forEach((block, i) => animateBlock(block, i * 200));
            proofObs.disconnect();
          }
        });
      }, { threshold: 0.5 });

      document.querySelectorAll('.stat-block').forEach(b => proofObs.observe(b));
    })();
  </script>

</body>
</html>
